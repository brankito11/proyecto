<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flores Rosadas</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: radial-gradient(ellipse at bottom, #1a1a2e 0%, #0f0f1e 50%, #050510 100%);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            margin: 0;
            padding: 0;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        .shooting-stars {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .shooting-star {
            position: absolute;
            width: 3px;
            height: 3px;
            background: white;
            border-radius: 50%;
            opacity: 0;
        }

        .shooting-star::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 80px;
            height: 2px;
            background: linear-gradient(90deg,
                    rgba(255, 255, 255, 0.8) 0%,
                    rgba(255, 255, 255, 0.4) 50%,
                    rgba(255, 255, 255, 0) 100%);
            transform: translateX(-80px) translateY(1px) rotate(-35deg);
            transform-origin: right center;
        }

        @keyframes shootingStar {
            0% {
                opacity: 0;
                transform: translateX(0) translateY(0) rotate(-35deg);
            }

            5% {
                opacity: 1;
            }

            100% {
                opacity: 0;
                transform: translateX(140px) translateY(100px) rotate(-35deg);
            }
        }

        .message {
            position: absolute;
            top: 12%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Great Vibes', cursive;
            font-size: 64px;
            color: #ffcce0;
            text-shadow: 0 0 20px rgba(255, 204, 224, 0.7),
                0 0 40px rgba(255, 204, 224, 0.4),
                0 3px 10px rgba(0, 0, 0, 0.5);
            opacity: 0;
            white-space: nowrap;
            letter-spacing: 3px;
            font-weight: 400;
            padding: 0 20px;
            text-align: center;
        }

        /* Responsive para móviles */
        @media (max-width: 768px) {
            .message {
                font-size: 48px;
                top: 8%;
                letter-spacing: 2px;
            }
        }

        @media (max-width: 480px) {
            .message {
                font-size: 36px;
                top: 5%;
                letter-spacing: 1px;
                white-space: normal;
                max-width: 90%;
            }
        }

        .message.show {
            animation: fadeInGlow 2.5s ease-out forwards;
        }

        @keyframes fadeInGlow {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(-25px) scale(0.95);
                text-shadow: 0 0 5px rgba(255, 204, 224, 0.2);
            }

            50% {
                text-shadow: 0 0 35px rgba(255, 204, 224, 0.9),
                    0 0 60px rgba(255, 204, 224, 0.5);
            }

            100% {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1);
                text-shadow: 0 0 20px rgba(255, 204, 224, 0.7),
                    0 0 40px rgba(255, 204, 224, 0.4),
                    0 3px 10px rgba(0, 0, 0, 0.5);
            }
        }

        .start-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 50px;
            font-size: 24px;
            font-family: 'Great Vibes', cursive;
            color: white;
            background: linear-gradient(135deg, #ff66b3 0%, #ff8cc4 100%);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(255, 102, 179, 0.4);
            transition: all 0.3s ease;
            z-index: 100;
        }

        @media (max-width: 480px) {
            .start-button {
                padding: 15px 35px;
                font-size: 20px;
            }
        }

        .start-button:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 15px 40px rgba(255, 102, 179, 0.6);
        }

        .start-button.hidden {
            display: none;
        }
    </style>
</head>

<body>
    <div class="shooting-stars" id="shootingStars"></div>
    <canvas id="flowerCanvas"></canvas>
    <div class="message" id="message">Feliz Navidad thais</div>
    <button class="start-button" id="startButton">Iniciar Animación</button>

    <script>
        const canvas = document.getElementById('flowerCanvas');
        const ctx = canvas.getContext('2d');
        const shootingStarsContainer = document.getElementById('shootingStars');
        const startButton = document.getElementById('startButton');
        const message = document.getElementById('message');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let time = 0;
        let animationStarted = false;
        let shootingStarInterval = null;
        let animationFrameId = null;

        function createShootingStar() {
            const star = document.createElement('div');
            star.className = 'shooting-star';

            star.style.left = (10 + Math.random() * 60) + '%';
            star.style.top = (5 + Math.random() * 30) + '%';

            const duration = 1.5 + Math.random() * 1;
            star.style.animation = `shootingStar ${duration}s ease-out`;

            if (Math.random() > 0.7) {
                star.style.background = '#ffe680';
                star.querySelector = star.after;
            }

            shootingStarsContainer.appendChild(star);

            setTimeout(() => {
                star.remove();
            }, duration * 1000);
        }

        startButton.addEventListener('click', () => {
            animationStarted = true;
            startButton.classList.add('hidden');

            // Iniciar estrellas fugaces inmediatamente
            shootingStarInterval = setInterval(() => {
                createShootingStar();
            }, 800);

            // Crear algunas estrellas iniciales
            setTimeout(() => createShootingStar(), 200);
            setTimeout(() => createShootingStar(), 600);
            setTimeout(() => createShootingStar(), 1200);

            // Mostrar mensaje después de la animación
            setTimeout(() => {
                message.classList.add('show');
            }, 6500);

            animate();
        });

        class GrassBlade {
            constructor(x, y, height, angle, delay) {
                this.x = x;
                this.y = y;
                this.maxHeight = height;
                this.angle = angle;
                this.delay = delay;
                this.growth = 0;
                this.windPhase = Math.random() * Math.PI * 2;
                this.curvature = (Math.random() - 0.5) * 0.3;
            }

            update(globalTime) {
                const t = globalTime - this.delay;
                if (t > 0) {
                    this.growth = Math.min(1, t / 1.5);
                    this.growth = 1 - Math.pow(1 - this.growth, 3);
                }
            }

            draw(windTime) {
                if (this.growth === 0) return;

                const currentHeight = this.maxHeight * this.growth;
                const windSway = Math.sin(windTime * 0.4 + this.windPhase) * 4;
                const windTip = Math.sin(windTime * 0.5 + this.windPhase + 1) * 6;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(
                    windSway + this.curvature * currentHeight * 0.3,
                    -currentHeight * 0.5,
                    windTip + this.curvature * currentHeight,
                    -currentHeight
                );

                const gradient = ctx.createLinearGradient(0, 0, windTip, -currentHeight);
                gradient.addColorStop(0, 'rgba(45, 110, 45, 0.9)');
                gradient.addColorStop(0.4, 'rgba(60, 150, 60, 0.95)');
                gradient.addColorStop(1, 'rgba(80, 190, 80, 1)');

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2.5;
                ctx.lineCap = 'round';
                ctx.stroke();

                ctx.strokeStyle = 'rgba(120, 240, 120, 0.15)';
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.restore();
            }
        }

        class Flower {
            constructor(x, y, size, stemHeight, delay) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.stemHeight = stemHeight;
                this.delay = delay;
                this.stemGrowth = 0;
                this.petalGrowth = 0;
                this.windOffset = Math.random() * Math.PI * 2;

                this.leaves = [
                    { y: 0.3, angle: -0.5, side: -1 },
                    { y: 0.5, angle: 0.5, side: 1 },
                    { y: 0.7, angle: -0.4, side: -1 }
                ];
            }

            update(globalTime) {
                const t = globalTime - this.delay;

                if (t > 1.5) {
                    this.stemGrowth = Math.min(1, (t - 1.5) / 2.5);
                    this.stemGrowth = 1 - Math.pow(1 - this.stemGrowth, 3);
                }

                if (t > 4 && this.stemGrowth === 1) {
                    this.petalGrowth = Math.min(1, (t - 4) / 2);
                    this.petalGrowth = 1 - Math.pow(1 - this.petalGrowth, 4);
                }
            }

            draw(windTime) {
                if (this.stemGrowth === 0) return;

                const windSway = Math.sin(windTime * 0.5 + this.windOffset) * 5;

                this.drawStem(windSway);

                if (this.stemGrowth > 0.4) {
                    this.drawLeaves(windSway, windTime);
                }

                if (this.petalGrowth > 0) {
                    this.drawFlowerBloom(windSway, windTime);
                }
            }

            drawStem(windSway) {
                const startY = this.y;
                const endY = this.y - this.stemHeight * this.stemGrowth;

                ctx.beginPath();
                ctx.moveTo(this.x, startY);
                ctx.quadraticCurveTo(
                    this.x + windSway * 0.3,
                    (startY + endY) / 2,
                    this.x + windSway * 0.6,
                    endY
                );

                const gradient = ctx.createLinearGradient(this.x, startY, this.x, endY);
                gradient.addColorStop(0, '#2d5d5d');
                gradient.addColorStop(0.5, '#40a0a0');
                gradient.addColorStop(1, '#5cc0c0');

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(this.x + 2, startY);
                ctx.quadraticCurveTo(
                    this.x + windSway * 0.3 + 2,
                    (startY + endY) / 2,
                    this.x + windSway * 0.6 + 2,
                    endY
                );
                ctx.strokeStyle = 'rgba(120, 220, 220, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            drawLeaves(windSway, time) {
                this.leaves.forEach((leaf, idx) => {
                    const leafProgress = Math.max(0, Math.min(1, (this.stemGrowth - 0.4 - idx * 0.1) * 2));
                    if (leafProgress === 0) return;

                    const leafY = this.y - this.stemHeight * this.stemGrowth * leaf.y;
                    const leafX = this.x + windSway * 0.6 * leaf.y;
                    const windLeaf = Math.sin(time * 0.5 + this.windOffset + idx) * 0.1;

                    ctx.save();
                    ctx.translate(leafX, leafY);
                    ctx.rotate(leaf.angle + windLeaf);
                    ctx.scale(leafProgress, leafProgress);

                    ctx.beginPath();
                    ctx.ellipse(leaf.side * this.size * 0.4, 0, this.size * 0.35, this.size * 0.65, 0, 0, Math.PI * 2);

                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size * 0.6);
                    gradient.addColorStop(0, '#70e6e6');
                    gradient.addColorStop(0.5, '#50d0d0');
                    gradient.addColorStop(1, '#40b0b0');

                    ctx.fillStyle = gradient;
                    ctx.fill();

                    ctx.beginPath();
                    ctx.ellipse(leaf.side * this.size * 0.3, -this.size * 0.2, this.size * 0.18, this.size * 0.35, 0, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(180, 255, 255, 0.5)';
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(120, 230, 230, 0.4)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    ctx.restore();
                });
            }

            drawFlowerBloom(windSway, time) {
                const flowerX = this.x + windSway * 0.6;
                const flowerY = this.y - this.stemHeight;
                const windRotate = Math.sin(time * 0.5 + this.windOffset) * 0.03;

                ctx.save();
                ctx.translate(flowerX, flowerY);

                const outerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size * 1.8 * this.petalGrowth);
                outerGlow.addColorStop(0, 'rgba(255, 180, 220, 0.3)');
                outerGlow.addColorStop(0.5, 'rgba(255, 180, 220, 0.1)');
                outerGlow.addColorStop(1, 'rgba(255, 180, 220, 0)');

                ctx.beginPath();
                ctx.arc(0, 0, this.size * 1.8 * this.petalGrowth, 0, Math.PI * 2);
                ctx.fillStyle = outerGlow;
                ctx.fill();

                // Exactamente 5 pétalos idénticos
                const petalCount = 5;
                for (let i = 0; i < petalCount; i++) {
                    const baseAngle = (Math.PI * 2 / petalCount) * i - Math.PI / 2;
                    const petalDelay = i * 0.12;
                    const petalProgress = Math.max(0, Math.min(1, (this.petalGrowth - petalDelay) * 1.4));

                    if (petalProgress === 0) continue;

                    const angle = baseAngle + windRotate;

                    ctx.save();
                    ctx.rotate(angle);

                    // Todos los pétalos del mismo tamaño
                    const finalScale = petalProgress;
                    ctx.scale(finalScale, finalScale);

                    ctx.beginPath();
                    ctx.ellipse(0, -this.size * 0.7, this.size * 0.52, this.size * 0.85, 0, 0, Math.PI * 2);

                    const petalGrad = ctx.createRadialGradient(0, -this.size * 0.45, 0, 0, -this.size * 0.7, this.size * 0.95);
                    petalGrad.addColorStop(0, '#fff5f8');
                    petalGrad.addColorStop(0.2, '#ffe6f0');
                    petalGrad.addColorStop(0.5, '#ffb3d6');
                    petalGrad.addColorStop(0.75, '#ff8cc4');
                    petalGrad.addColorStop(1, '#ff66b3');

                    ctx.fillStyle = petalGrad;
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(255, 180, 220, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.ellipse(-this.size * 0.15, -this.size * 0.6, this.size * 0.22, this.size * 0.4, 0, 0, Math.PI * 2);
                    const highlightGrad = ctx.createRadialGradient(-this.size * 0.15, -this.size * 0.6, 0, -this.size * 0.15, -this.size * 0.6, this.size * 0.4);
                    highlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
                    highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = highlightGrad;
                    ctx.fill();

                    ctx.restore();
                }

                if (this.petalGrowth > 0.3) {
                    const centerProgress = Math.min(1, (this.petalGrowth - 0.3) * 1.5);

                    ctx.scale(centerProgress, centerProgress);

                    const centerGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size * 0.4);
                    centerGrad.addColorStop(0, '#fffef5');
                    centerGrad.addColorStop(0.3, '#fff8d0');
                    centerGrad.addColorStop(0.6, '#ffe680');
                    centerGrad.addColorStop(1, '#ffd966');

                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 0.38, 0, Math.PI * 2);
                    ctx.fillStyle = centerGrad;
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(255, 220, 100, 0.8)';
                    ctx.lineWidth = 2.5;
                    ctx.stroke();

                    for (let i = 0; i < 8; i++) {
                        const a = (Math.PI * 2 / 8) * i + time * 0.2;
                        const px = Math.cos(a) * this.size * 0.22;
                        const py = Math.sin(a) * this.size * 0.22;

                        ctx.beginPath();
                        ctx.arc(px, py, 2.5, 0, Math.PI * 2);
                        ctx.fillStyle = '#ffaa33';
                        ctx.fill();

                        ctx.beginPath();
                        ctx.arc(px, py, 1.2, 0, Math.PI * 2);
                        ctx.fillStyle = '#fffacd';
                        ctx.fill();
                    }
                }

                ctx.restore();
            }
        }

        const centerX = canvas.width / 2;
        const bottomY = canvas.height * 0.82;

        // Ajustar cantidad de pasto según el ancho de pantalla
        const isMobile = canvas.width < 768;
        const grassCount = isMobile ? 25 : 40;
        const grassSpread = isMobile ? 400 : 700;

        const grassBlades = [];
        for (let i = 0; i < grassCount; i++) {
            const x = centerX - grassSpread / 2 + Math.random() * grassSpread;
            const y = bottomY + Math.random() * 40;
            const height = 60 + Math.random() * 60;
            const angle = (Math.random() - 0.5) * 0.3;
            const delay = Math.random() * 0.8;
            grassBlades.push(new GrassBlade(x, y, height, angle, delay));
        }

        // Ajustar tamaño y posición de flores según pantalla
        const flowerSize = isMobile ? 40 : 50;
        const flowerSpacing = isMobile ? 80 : 130;
        const flowerHeight = isMobile ? 180 : 210;

        const flowers = [
            new Flower(centerX - flowerSpacing, bottomY, flowerSize, flowerHeight, 0),
            new Flower(centerX + 10, bottomY - 10, flowerSize + 8, flowerHeight + 40, 0.4),
            new Flower(centerX + flowerSpacing, bottomY + 5, flowerSize + 2, flowerHeight + 10, 0.8)
        ];

        function animate() {
            if (!animationStarted) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            time += 0.016;
            const windTime = time * 1.2;

            grassBlades.forEach(blade => {
                blade.update(time);
                blade.draw(windTime);
            });

            flowers.forEach(flower => {
                flower.update(time);
                flower.draw(windTime);
            });

            animationFrameId = requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            const oldWidth = canvas.width;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Solo reiniciar si hay un cambio significativo (ej: rotación de móvil)
            if (Math.abs(oldWidth - canvas.width) > 100 && animationStarted) {
                location.reload(); // Recargar para recalcular posiciones
            }
        });
    </script>
</body>

</html>